<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Lux Chess — LLM vs LLM, rule-free</title>
	<link
		href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;600;800;900&family=JetBrains+Mono:wght@400;700&display=swap"
		rel="stylesheet">
	<style>
		:root {
			--bg-1: #0b1020;
			--bg-2: #0d0f1a;
			--ink: #dfe6ff;
			--muted: #8fa1ffb3;
			--accent: #7aa2ff;
			--accent-2: #c77dff;
			--ok: #4ade80;
			--err: #ff6b6b;
			--glass: rgba(255, 255, 255, 0.08);
			--glass-2: rgba(255, 255, 255, 0.12);
			--board-dark: #1b2440;
			--board-light: #222c55;
			--board-glow: #6ba3ff88;
			--shadow: 0 10px 35px rgba(0, 0, 0, 0.45);
			--radius: 22px;
			--tile: 86px;
			/* board tile size; responsive down below */
		}

		@media (max-width:1200px) {
			:root {
				--tile: 72px;
			}
		}

		@media (max-width:960px) {
			:root {
				--tile: 64px;
			}
		}

		@media (max-width:820px) {
			:root {
				--tile: 56px;
			}
		}

		@media (max-width:720px) {
			:root {
				--tile: 52px;
			}
		}

		@media (max-width:640px) {
			:root {
				--tile: 46px;
			}
		}

		/* Background */
		html,
		body {
			height: 100%
		}

		body {
			margin: 0;
			background: radial-gradient(1200px 800px at 20% -10%, #22306655 0%, transparent 60%),
				radial-gradient(900px 900px at 120% 10%, #311a6650 0%, transparent 60%),
				radial-gradient(600px 600px at 50% 120%, #004b8870 0%, transparent 60%),
				linear-gradient(135deg, var(--bg-1), var(--bg-2));
			font-family: Outfit, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
			color: var(--ink);
			overflow-x: hidden;
		}

		.glow-orb {
			position: fixed;
			inset: auto;
			pointer-events: none;
			filter: blur(60px);
			opacity: .6;
			mix-blend-mode: screen;
			width: 600px;
			height: 600px;
			border-radius: 50%;
			background: radial-gradient(circle at 50% 50%, #7aa2ff 0%, #7aa2ff33 35%, transparent 60%);
			animation: float 18s ease-in-out infinite;
		}

		.glow-orb.o2 {
			background: radial-gradient(circle, #c77dff, #c77dff33 40%, transparent 70%);
			animation-duration: 24s
		}

		.glow-orb.o3 {
			background: radial-gradient(circle, #00e6a8, #00e6a833 40%, transparent 70%);
			animation-duration: 28s
		}

		@keyframes float {
			0% {
				transform: translate(-20vw, -10vh)
			}

			50% {
				transform: translate(10vw, 10vh)
			}

			100% {
				transform: translate(-20vw, -10vh)
			}
		}

		/* Layout */
		.wrap {
			max-width: 1400px;
			margin: 42px auto;
			padding: 0 20px;
			position: relative
		}

		.topbar {
			display: flex;
			gap: 12px;
			align-items: center;
			justify-content: center;
			margin-bottom: 18px;
			backdrop-filter: blur(10px);
			background: linear-gradient(180deg, rgba(255, 255, 255, 0.10), rgba(255, 255, 255, 0.06));
			border: 1px solid rgba(255, 255, 255, 0.14);
			box-shadow: var(--shadow);
			padding: 14px 16px;
			border-radius: 18px;
		}

		.topbar .field {
			display: flex;
			align-items: center;
			gap: 10px;
			background: var(--glass);
			padding: 10px 12px;
			border-radius: 14px;
			border: 1px solid rgba(255, 255, 255, 0.14)
		}

		.label {
			font-size: 12px;
			letter-spacing: .3px;
			color: var(--muted)
		}

		input[type="password"],
		input[type="text"],
		input[type="url"] {
			background: transparent;
			border: none;
			outline: none;
			color: var(--ink);
			font: 600 14px/1 JetBrains Mono, monospace;
			width: clamp(160px, 24vw, 420px);
		}

		input::placeholder {
			color: #9fb2ff88
		}

		.url {
			width: clamp(140px, 20vw, 360px);
		}

		.board-row {
			display: grid;
			grid-template-columns: auto 1fr auto;
			gap: 20px;
			align-items: start
		}

		/* Side menus */
		.side {
			width: 240px;
			min-width: 220px;
			display: flex;
			flex-direction: column;
			gap: 14px;
			position: relative;
			backdrop-filter: blur(12px);
			background: linear-gradient(180deg, rgba(255, 255, 255, 0.10), rgba(255, 255, 255, 0.05));
			border: 1px solid rgba(255, 255, 255, 0.16);
			box-shadow: var(--shadow);
			padding: 16px;
			border-radius: 18px;
		}

		.side .title {
			font-weight: 800;
			letter-spacing: .6px;
			font-size: 14px;
			color: #eaf0ff
		}

		.side .box {
			background: var(--glass);
			border: 1px solid rgba(255, 255, 255, 0.14);
			border-radius: 14px;
			padding: 12px;
			display: flex;
			flex-direction: column;
			gap: 8px
		}

		.side input {
			width: 100%
		}

		.play {
			cursor: pointer;
			user-select: none;
			border: none;
			border-radius: 14px;
			padding: 12px 14px;
			font-weight: 800;
			letter-spacing: .4px;
			color: #0b1020;
			background: linear-gradient(135deg, #7aa2ff, #9b7dff 70%);
			box-shadow: 0 10px 30px #7aa2ff55, inset 0 0 0 1px #ffffff40;
			transition: transform .08s ease, filter .2s ease, opacity .2s ease;
		}

		.play.black {
			background: linear-gradient(135deg, #c77dff, #7ad6ff 70%)
		}

		.play:active {
			transform: translateY(1px) scale(.99)
		}

		.play[disabled] {
			opacity: .6;
			cursor: not-allowed;
			filter: grayscale(.3)
		}

		/* Board shell */
		.board-shell {
			position: relative;
			width: calc(var(--tile)*8);
			height: calc(var(--tile)*8);
			border-radius: var(--radius);
			box-shadow: var(--shadow), 0 0 0 1px rgba(255, 255, 255, 0.18) inset;
			background:
				linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.02)),
				radial-gradient(120% 120% at 20% 15%, rgba(255, 255, 255, 0.10), transparent 60%),
				linear-gradient(135deg, #0b1130 0%, #0a0f27 100%);
			overflow: hidden;
		}

		/* Board grid */
		.board {
			position: absolute;
			inset: 12px;
			display: grid;
			grid-template-columns: repeat(8, 1fr);
			grid-template-rows: repeat(8, 1fr);
			border-radius: 14px;
			overflow: hidden;
			box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.06)
		}

		.square {
			position: relative;
			display: flex;
			align-items: center;
			justify-content: center;
			font-weight: 700;
			user-select: none;
			-webkit-user-select: none;
		}

		.square.dark {
			background:
				radial-gradient(200% 200% at 70% 30%, #2a3566 0%, transparent 60%),
				linear-gradient(180deg, #1d264d, #151d3a);
		}

		.square.light {
			background:
				radial-gradient(200% 200% at 30% 70%, #2e497a 0%, transparent 60%),
				linear-gradient(180deg, #223062, #1a2447);
		}

		.square::after {
			content: "";
			position: absolute;
			inset: -1px;
			border: 1px solid rgba(255, 255, 255, 0.05);
			pointer-events: none;
		}

		.square .coord {
			position: absolute;
			font: 700 10px/1 JetBrains Mono, monospace;
			color: #9fb2ff77;
			opacity: .9;
		}

		.square.file .coord {
			bottom: 6px;
			left: 6px
		}

		.square.rank .coord {
			top: 6px;
			right: 6px
		}

		/* Pieces */
		.layer {
			position: absolute;
			inset: 12px;
			pointer-events: none
		}

		.piece {
			position: absolute;
			width: calc(var(--tile) * .86);
			height: calc(var(--tile) * .86);
			display: flex;
			align-items: center;
			justify-content: center;
			transform: translate(var(--x, 0), var(--y, 0)) scale(1);
			transition: transform .27s cubic-bezier(.2, .8, .2, 1), filter .2s ease, opacity .2s ease;
			will-change: transform;
			pointer-events: auto;
			cursor: grab;
			z-index: 2;
			filter: drop-shadow(0 12px 12px rgba(0, 0, 0, .35));
		}

		.piece.dragging {
			cursor: grabbing;
			transition: none;
			z-index: 20
		}

		.glyph {
			font-size: calc(var(--tile) * .74);
			line-height: 1;
			background: linear-gradient(180deg, #fff, #e6eeff);
			-webkit-background-clip: text;
			background-clip: text;
			-webkit-text-fill-color: transparent;
			text-shadow: 0 2px 0 #ffffff22, 0 10px 30px #7aa2ff55;
		}

		.black .glyph {
			background: linear-gradient(180deg, #dfe6ff, #9fb2ff);
			-webkit-background-clip: text;
			background-clip: text;
			-webkit-text-fill-color: transparent;
			text-shadow: 0 2px 0 #ffffff22, 0 10px 30px #c77dff44;
			opacity: .95
		}

		.halo {
			position: absolute;
			inset: 0;
			border-radius: 16px;
			box-shadow: 0 0 0 0 var(--board-glow);
			opacity: 0;
			transition: opacity .3s
		}

		.piece:hover .halo {
			opacity: 1;
			box-shadow: 0 0 0 6px var(--board-glow)
		}

		.last-move {
			position: absolute;
			inset: 12px;
			pointer-events: none;
			z-index: 0;
		}

		.pulse {
			position: absolute;
			width: calc(var(--tile));
			height: calc(var(--tile));
			border-radius: 10px;
			transform: translate(var(--x, 0), var(--y, 0)) scale(1);
			background: radial-gradient(circle at 50% 50%, #7aa2ff55, transparent 60%);
			animation: pulse 1.1s ease-out;
		}

		@keyframes pulse {
			0% {
				opacity: .75;
				transform: translate(var(--x, 0), var(--y, 0)) scale(.6)
			}

			100% {
				opacity: 0;
				transform: translate(var(--x, 0), var(--y, 0)) scale(1.3)
			}
		}

		/* Capture pop */
		.pop {
			position: absolute;
			width: 12px;
			height: 12px;
			border-radius: 999px;
			background: linear-gradient(180deg, #fff, #a6baff);
			box-shadow: 0 0 0 8px #8fb1ff30, 0 0 40px #7aa2ff80;
			opacity: .85;
			pointer-events: none;
			z-index: 5;
			animation: pop .35s ease-out forwards;
		}

		@keyframes pop {
			to {
				transform: scale(6);
				opacity: 0
			}
		}

		/* Hints and toasts */
		.toast {
			position: fixed;
			bottom: 18px;
			left: 50%;
			transform: translateX(-50%);
			background: linear-gradient(180deg, rgba(255, 255, 255, .12), rgba(255, 255, 255, .06));
			border: 1px solid rgba(255, 255, 255, .18);
			padding: 10px 14px;
			border-radius: 12px;
			font: 600 13px JetBrains Mono, monospace;
			color: #eaf0ff;
			box-shadow: var(--shadow);
			opacity: 0;
			pointer-events: none;
			transition: opacity .2s, transform .2s;
			z-index: 100
		}

		.toast.show {
			opacity: 1;
			transform: translateX(-50%) translateY(-4px)
		}

		.hint {
			font-size: 12px;
			color: #9fb2ff99;
			text-align: center;
			margin-top: 4px
		}

		/* Footer small */
		.small {
			margin-top: 10px;
			font-size: 12px;
			color: #9fb2ff88;
			text-align: center
		}

		.kbd {
			font: 700 11px JetBrains Mono, monospace;
			color: #eaf0ff;
			background: #ffffff14;
			padding: 3px 6px;
			border-radius: 8px;
			border: 1px solid #ffffff24
		}

		/* add anywhere in <style> */
		.piece.captured {
			pointer-events: none;
			opacity: 0;
			transform: translate(var(--x), var(--y)) scale(.7);
			transition: transform .18s ease, opacity .18s ease;
		}
	</style>
</head>

<body>
	<div class="glow-orb" style="top:8vh;left:-6vw"></div>
	<div class="glow-orb o2" style="bottom:-10vh;right:-8vw"></div>
	<div class="glow-orb o3" style="top:50vh;left:50vw"></div>

	<div class="wrap">
		<!-- Top menu -->
		<div class="topbar">
			<div class="field">
				<div class="label">API key</div>
				<input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" />
			</div>
			<div class="field">
				<div class="label">URL</div>
				<input id="apiUrl" class="url" type="url" placeholder="https://api.openai.com/v1/responses" />
			</div>
		</div>

		<div class="board-row">
			<!-- Left menu (White) -->
			<aside class="side">
				<div class="title">White engine</div>
				<div class="box">
					<div class="label">Model name</div>
					<input id="whiteModel" type="text" placeholder="gpt-4.1-mini" />
				</div>
				<button id="playWhite" class="play">Play ▸ White</button>
				<div class="hint">Drag pieces freely. No rules enforced.</div>
			</aside>

			<!-- Board -->
			<section class="board-shell" id="boardShell" aria-label="Chess board">
				<div class="board" id="board"></div>
				<div class="layer" id="pieces"></div>
				<div class="last-move" id="lastMove"></div>
			</section>

			<!-- Right menu (Black) -->
			<aside class="side">
				<div class="title">Black engine</div>
				<div class="box">
					<div class="label">Model name</div>
					<input id="blackModel" type="text" placeholder="gpt-4.1-mini" />
				</div>
				<button id="playBlack" class="play black">Play ▸ Black</button>
				<div class="hint">Captures allowed on any color.</div>
			</aside>
		</div>

		<div class="small">Tip: <span class="kbd">R</span> to reset. <span class="kbd">F</span> to flip view.</div>
	</div>

	<div id="toast" class="toast"></div>

	<script>
		/* ===============================
		   LUX CHESS — single-file, rule-free
		   - Beautiful board with glass UI
		   - Drag anywhere, capture anything
		   - Two side menus with model + play
		   - Top menu for API key + URL
		   - LLM move via OpenAI-compatible /v1/responses
		   - Strict JSON schema: { to: "e4", from?: "a2" }
		   =============================== */

		const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
		const ranks = [1, 2, 3, 4, 5, 6, 7, 8];
		let state = {pieces: [], flipped: false, moveCount: 0};

		const elBoard = document.getElementById('board');
		const elLayer = document.getElementById('pieces');
		const elLast = document.getElementById('lastMove');
		const elShell = document.getElementById('boardShell');

		const elApiKey = document.getElementById('apiKey');
		const elApiUrl = document.getElementById('apiUrl');
		const elWhiteModel = document.getElementById('whiteModel');
		const elBlackModel = document.getElementById('blackModel');
		const btnWhite = document.getElementById('playWhite');
		const btnBlack = document.getElementById('playBlack');

		// === sizes ===
		function cell() {
			// real tile pixels inside the inset layer
			const r = elLayer.getBoundingClientRect();
			return r.width / 8; // square board, height matches
		}
		const PIECE_SCALE = 0.86;
		function pieceSize() {return cell() * PIECE_SCALE;}
		function pieceOffset() {return (cell() - pieceSize()) / 2;}


		const toast = (msg, ok = false) => {
			const t = document.getElementById('toast');
			t.textContent = msg;
			t.style.borderColor = ok ? 'rgba(74,222,128,.6)' : 'rgba(255,107,107,.5)';
			t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 1800);
		};

		// ADD helper and use it everywhere you set piece position:
		// === apply piece position ===
		function setPiecePos(el, sq) {
			const {x, y} = coordToXY(sq);
			const off = pieceOffset();
			el.style.setProperty('--x', (x + off) + 'px');
			el.style.setProperty('--y', (y + off) + 'px');
		}


		// REPLACE coordToXY with:
		// === coords ===
		function coordToXY(square) {
			const c = cell();
			const fx = files.indexOf(square[0]);
			const ry = parseInt(square[1], 10) - 1;
			const x = (state.flipped ? (7 - fx) : fx) * c;
			const y = (state.flipped ? ry : (7 - ry)) * c;
			return {x, y}; // layer coords
		}

		function squareFromClient(clientX, clientY) {
			const rect = elLayer.getBoundingClientRect();
			const c = cell();
			let x = Math.max(0, Math.min(rect.width, clientX - rect.left));
			let y = Math.max(0, Math.min(rect.height, clientY - rect.top));
			const fx = Math.min(7, Math.max(0, Math.floor(x / c)));
			const fy = Math.min(7, Math.max(0, Math.floor(y / c)));
			const file = state.flipped ? files[7 - fx] : files[fx];
			const rank = state.flipped ? (fy + 1) : (8 - fy);
			return file + rank;
		}

		function getTile() {return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--tile'));}

		function buildBoard() {
			elBoard.innerHTML = '';
			for (let r = 8; r >= 1; r--) {
				for (let f = 0; f < 8; f++) {
					const sq = document.createElement('div');
					const dark = (r + f) % 2 === 1;
					sq.className = 'square ' + (dark ? 'dark' : 'light');
					if (f === 0) {const label = document.createElement('div'); label.className = 'coord'; label.textContent = r; sq.classList.add('rank'); sq.appendChild(label);}
					if (r === 1) {const label = document.createElement('div'); label.className = 'coord'; label.textContent = files[f]; sq.classList.add('file'); sq.appendChild(label);}
					elBoard.appendChild(sq);
				}
			}
		}
		function initialPieces() {
			const P = [];
			const add = (type, color, sq) => P.push({id: crypto.randomUUID(), type, color, sq});
			// Pawns
			files.forEach((f) => add('P', 'white', `${f}2`));
			files.forEach((f) => add('P', 'black', `${f}7`));
			// Rooks
			add('R', 'white', 'a1'); add('R', 'white', 'h1');
			add('R', 'black', 'a8'); add('R', 'black', 'h8');
			// Knights
			add('N', 'white', 'b1'); add('N', 'white', 'g1');
			add('N', 'black', 'b8'); add('N', 'black', 'g8');
			// Bishops
			add('B', 'white', 'c1'); add('B', 'white', 'f1');
			add('B', 'black', 'c8'); add('B', 'black', 'f8');
			// Queens
			add('Q', 'white', 'd1'); add('Q', 'black', 'd8');
			// Kings
			add('K', 'white', 'e1'); add('K', 'black', 'e8');
			return P;
		}
		const glyph = (t, c) => ({
			white: {K: '♔', Q: '♕', R: '♖', B: '♗', N: '♘', P: '♙'}[t],
			black: {K: '♚', Q: '♛', R: '♜', B: '♝', N: '♞', P: '♟'}[t]
		}[c]);

		// === render with correct sizes ===
		function renderPieces() {
			elLayer.innerHTML = '';
			const w = pieceSize();
			const gsz = cell() * 0.74;
			state.pieces.forEach(p => {
				const d = document.createElement('div');
				d.className = `piece ${p.color}`;
				d.dataset.id = p.id;
				d.dataset.sq = p.sq;
				d.dataset.color = p.color;
				d.dataset.type = p.type;
				d.style.width = w + 'px';
				d.style.height = w + 'px';
				d.innerHTML = `<div class="halo"></div><div class="glyph" style="font-size:${gsz}px">${glyph(p.type, p.color)}</div>`;
				setPiecePos(d, p.sq);
				attachDrag(d);
				elLayer.appendChild(d);
			});
		}




		function pieceAt(square) {return state.pieces.find(p => p.sq === square);}
		function piecesOf(color) {return state.pieces.filter(p => p.color === color);}
		function removeAt(square) {
			const k = state.pieces.findIndex(p => p.sq === square);
			if (k >= 0) {const [dead] = state.pieces.splice(k, 1); return dead;}
			return null;
		}
		// replace your movePiece with this
		function movePiece(id, to) {
			const p = state.pieces.find(x => x.id === id); if (!p) return;
			const from = p.sq;
			const victim = removeAt(to);            // update state first
			p.sq = to;

			// move mover
			const moverEl = elLayer.querySelector(`.piece[data-id="${id}"]`);
			if (moverEl) {setPiecePos(moverEl, to); moverEl.dataset.sq = to;}

			// kill victim in DOM
			if (victim) {
				const vEl = elLayer.querySelector(`.piece[data-id="${victim.id}"]`);
				if (vEl) {vEl.classList.add('captured'); setTimeout(() => vEl.remove(), 200);}
				const {x, y} = coordToXY(to);
				const pop = document.createElement('div'); pop.className = 'pop';
				pop.style.left = (x + cell() / 2 - 6) + 'px';
				pop.style.top = (y + cell() / 2 - 6) + 'px';
				elLayer.appendChild(pop); setTimeout(() => pop.remove(), 400);
			}

			pulse(from); pulse(to);
			purgeOrphans(); // safety
		}

		function pulse(square) {
			const {x, y} = coordToXY(square);
			const d = document.createElement('div'); d.className = 'pulse';
			d.style.setProperty('--x', x + 'px');
			d.style.setProperty('--y', y + 'px');
			elLast.appendChild(d); setTimeout(() => d.remove(), 1200);
		}

		/* Drag and drop */
		// === drag ===
		function attachDrag(el) {
			let drag = false;
			el.addEventListener('pointerdown', e => {
				e.preventDefault(); el.setPointerCapture(e.pointerId);
				el.classList.add('dragging'); drag = true;
			});
			el.addEventListener('pointermove', e => {
				if (!drag) return;
				const rect = elLayer.getBoundingClientRect();
				const sz = pieceSize();
				el.style.setProperty('--x', (e.clientX - rect.left - sz / 2) + 'px');
				el.style.setProperty('--y', (e.clientY - rect.top - sz / 2) + 'px');
			});
			el.addEventListener('pointerup', e => {
				if (!drag) return; drag = false; el.classList.remove('dragging');
				const to = squareFromClient(e.clientX, e.clientY);
				movePiece(el.dataset.id, to);
			});
			// inside attachDrag, at the top of pointerdown handler:
			el.addEventListener('pointerdown', e => {
				const exists = state.pieces.some(p => p.id === el.dataset.id);
				if (!exists) {el.remove(); return;}  // orphan, drop it
				e.preventDefault(); el.setPointerCapture(e.pointerId);
				el.classList.add('dragging'); drag = true;
			});

		}

		function purgeOrphans() {
			const ids = new Set(state.pieces.map(p => p.id));
			document.querySelectorAll('.piece').forEach(el => {
				if (!ids.has(el.dataset.id)) el.remove();
			});
		}



		/* Reset / Flip */
		function reset() {
			state.pieces = initialPieces();
			state.moveCount = 0;
			renderPieces();
		}
		// REPLACE flip() with:
		// === flip & resize ===
		function flip() {
			state.flipped = !state.flipped;
			document.querySelectorAll('.piece').forEach(el => setPiecePos(el, el.dataset.sq));
		}
		window.addEventListener('resize', () => renderPieces());

		/* Board build */
		buildBoard(); reset();
		window.addEventListener('resize', () => renderPieces());
		window.addEventListener('keydown', (e) => {
			if (e.key === 'r' || e.key === 'R') reset();
			if (e.key === 'f' || e.key === 'F') flip();
		});

		/* --------- LLM Move plumbing ---------- */

		const JSON_SCHEMA = {
			name: "move_choice",
			// OpenAI Responses API schema payload
			schema: {
				type: "object",
				additionalProperties: false,
				properties: {
					to: {type: "string", pattern: "^[a-h][1-8]$"},
					from: {type: "string", pattern: "^[a-h][1-8]$"}
				},
				required: ["to", "from"]
			},
			strict: true
		};

		function boardJSON() {
			return {
				flipped: state.flipped,
				moveCount: state.moveCount,
				pieces: state.pieces.map(p => ({type: p.type, color: p.color, sq: p.sq}))
			};
		}

		function findNearestMover(color, targetSq) {
			const tx = files.indexOf(targetSq[0]);
			const ty = parseInt(targetSq[1], 10) - 1;
			const list = piecesOf(color);
			if (!list.length) return null;
			let best = list[0], bestDist = 999;
			for (const p of list) {
				const fx = files.indexOf(p.sq[0]);
				const fy = parseInt(p.sq[1], 10) - 1;
				const d = Math.hypot(fx - tx, fy - ty);
				if (d < bestDist) {best = p; bestDist = d;}
			}
			return best;
		}

		const SQUARES = (() => {
			const f = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
			const r = ['1', '2', '3', '4', '5', '6', '7', '8'];
			const out = [];
			for (const ff of f) for (const rr of r) out.push(ff + rr);
			return out;
		})();

		/* Build per-move JSON Schema.
		   - 'to' must be any board square (enum of 64)
		   - 'from' if present must be one of mover's squares for that color
		*/
		function buildMoveJsonSchema(allowedFromSquares) {
			return {
				name: "move_choice",
				schema: {
					type: "object",
					additionalProperties: false,
					properties: {
						to: {type: "string", enum: SQUARES},
						from: {type: "string", enum: allowedFromSquares}
					},
					required: ["to", "from"]
				},
				strict: true
			};
		}

		function boardJSON() {
			return {
				flipped: state.flipped,
				moveCount: state.moveCount,
				pieces: state.pieces.map(p => ({type: p.type, color: p.color, sq: p.sq}))
			};
		}

		function findNearestMover(color, targetSq) {
			const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
			const tx = files.indexOf(targetSq[0]);
			const ty = parseInt(targetSq[1], 10) - 1;
			const list = state.pieces.filter(p => p.color === color);
			if (!list.length) return null;
			let best = list[0], bestDist = 999;
			for (const p of list) {
				const fx = files.indexOf(p.sq[0]);
				const fy = parseInt(p.sq[1], 10) - 1;
				const d = Math.hypot(fx - tx, fy - ty);
				if (d < bestDist) {best = p; bestDist = d;}
			}
			return best;
		}

		/* Robust extractor for Responses API structured output */
		function extractStructuredJSON(resp) {
			try {
				const content = resp?.output?.[0]?.content;
				if (Array.isArray(content)) {
					const j = content.find(x => x?.type === 'output_json');
					if (j && (j.output_json || j.json)) return j.output_json || j.json;
					const t = content.map(x => x?.text).filter(Boolean).join('').trim();
					if (t) return JSON.parse(t);
				}
			} catch { }
			try {if (typeof resp?.output_text === 'string') return JSON.parse(resp.output_text.trim());} catch { }
			try { // last resort
				const s = JSON.stringify(resp);
				const m = s.match(/\{(?:[^{}]|{[^{}]*})*}/);
				if (m) return JSON.parse(m[0]);
			} catch { }
			return null;
		}

		/* ================= REWRITTEN FUNCTION ================= */
		async function callLLMMove(who) {
			const color = who; // 'white' or 'black'
			const apiKey = elApiKey.value.trim();
			const url = (elApiUrl.value.trim() || 'https://api.openai.com/v1/responses');
			const model = (who === 'white' ? elWhiteModel.value.trim() : elBlackModel.value.trim()) || 'gpt-4.1-mini';

			if (!apiKey) {toast('Missing API key'); throw new Error('No API key');}

			const btn = who === 'white' ? btnWhite : btnBlack;
			btn.disabled = true; btn.textContent = 'Thinking…';

			// Allowed 'from' squares for this side
			const allowedFrom = state.pieces.filter(p => p.color === color).map(p => p.sq);
			const JSON_SCHEMA = buildMoveJsonSchema(allowedFrom);

			// const sys = `You select one chess move for your side. Output must be JSON that exactly matches the provided schema. No prose, no code fences.`;
			const sys = `You are a player in a chess game. Given the board you must choose a position to move a piece and the position of the piece to move from. 

You can't cheat or else you will lose the game.`;
			const usr =
				`You are ${color.toUpperCase()}.

Board:
${JSON.stringify(boardJSON(), null, 2)}`;

			const payload = {
				model,
				input: [
					{role: "system", content: [{type: "input_text", text: sys}]},
					{role: "user", content: [{type: "input_text", text: usr}]}
				],
				text: {
					format: {
						type: "json_schema",
						name: JSON_SCHEMA.name,
						schema: JSON_SCHEMA.schema,
						strict: JSON_SCHEMA.strict
					}
				}
			};

			const controller = new AbortController();
			const timeout = setTimeout(() => controller.abort(), 18000);

			try {
				const res = await fetch(url, {
					method: 'POST',
					headers: {
						'Authorization': 'Bearer ' + apiKey,
						'Content-Type': 'application/json',
						'Accept': 'application/json'
					},
					body: JSON.stringify(payload),
					signal: controller.signal
				});

				if (!res.ok) {
					let detail = '';
					try {detail = (await res.json())?.error?.message || res.statusText;} catch { }
					throw new Error(`HTTP ${res.status} ${detail}`.trim());
				}

				const data = await res.json();
				const move = extractStructuredJSON(data);

				if (!move || typeof move !== 'object') throw new Error('No structured JSON in response');
				if (!SQUARES.includes(move.to)) throw new Error('Invalid "to" square');
				if (move.from && !allowedFrom.includes(move.from)) delete move.from; // ignore bad 'from'

				// Pick mover
				let mover = null;
				if (move.from) {
					mover = state.pieces.find(x => x.sq === move.from && x.color === color) || null;
				}
				if (!mover) mover = findNearestMover(color, move.to);

				if (!mover) {toast('No piece available'); return;}
				movePiece(mover.id, move.to);
				state.moveCount++;
				toast(`${color} → ${move.to}`, true);

			} catch (err) {
				console.error(err);
				toast('LLM move failed');
			} finally {
				clearTimeout(timeout);
				btn.disabled = false; btn.textContent = who === 'white' ? 'Play ▸ White' : 'Play ▸ Black';
			}
		}

		/* Bind buttons */
		btnWhite.addEventListener('click', () => callLLMMove('white'));
		btnBlack.addEventListener('click', () => callLLMMove('black'));

		/* Accessibility: click board to select nearest piece then press a-h + 1-8 to send there */
		let selected = null;
		elLayer.addEventListener('click', e => {
			const el = e.target.closest('.piece'); if (!el) return;
			selected = el.dataset.id;
			pulse(el.dataset.sq);
		});
		window.addEventListener('keydown', e => {
			if (!selected) return;
			const key = e.key.toLowerCase();
			if (files.includes(key)) {selected = key; return;}
			if ('12345678'.includes(key) && typeof selected === 'string' && selected.length === 1) {
				const to = selected + key; // file + rank
				// choose the visually topmost piece under cursor? Use last clicked id stored earlier if length>1
				const all = Array.from(document.querySelectorAll('.piece'));
				const last = all[all.length - 1];
				const pid = last ? last.dataset.id : state.pieces[0]?.id;
				movePiece(pid, to); selected = null;
			}
		});
	</script>
</body>

</html>
