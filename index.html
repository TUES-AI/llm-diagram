<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MoE Transformer — Flow with Pointers (v4)</title>
<style>
  :root{
    --bg:#f6f7fb; --panel:#fff; --text:#0f172a; --muted:#475569; --line:#e5e7eb;
    --grid:rgba(17,24,39,0.06);
    --flow:#0284c7; --attn:#93c5fd; --moe:#c4b5fd; --ln:#86efac; --cache:#f59e0b;
    --pill:#eef2ff;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);
    font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  header{padding:16px 24px;border-bottom:1px solid var(--line);
    background:linear-gradient(180deg,rgba(2,6,23,.03),transparent);}
  h1{margin:0;font-size:18px}
  .sub{margin-top:6px;color:var(--muted);font-size:13px}
  .legend{padding:10px 24px;color:var(--muted);font-size:12px;display:flex;flex-wrap:wrap;gap:8px}
  .pillchip{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid var(--line);
    border-radius:999px;background:var(--pill);color:var(--text)}
  .sw{width:12px;height:12px;border-radius:2px;display:inline-block}
  /* Flow viewport */
  .wrap{position:relative;border-top:1px solid var(--line);background:var(--panel);overflow-x:auto;overflow-y:hidden}
  .flow{
    position:relative;min-width:1000px;width:max-content;display:inline-block;padding:32px 40px 80px;
    background:
      linear-gradient(90deg,var(--grid) 1px,transparent 1px) 0 0/40px 40px,
      linear-gradient(var(--grid) 1px,transparent 1px) 0 0/40px 40px;
  }
  .band{position:relative;display:grid;grid-auto-flow:column;grid-auto-columns:260px;column-gap:36px;align-items:start}
  .band.bottom{margin-top:80px}
  .node{position:relative;background:#fff;border:1px solid var(--line);border-radius:10px;padding:10px 12px;box-shadow:0 2px 8px rgba(0,0,0,.04)}
  .node.small{width:140px}
  .title{font-size:13px;font-weight:700;text-align:center}
  .meta{font-size:11px;color:var(--muted);text-align:center;margin-top:4px;white-space:nowrap}
  .badge{position:absolute;top:-10px;left:12px;font-size:11px;padding:3px 8px;border-radius:999px;border:1px solid var(--line);background:#fff;color:#6b7280}
  .badge.attn{background:#eff6ff;border-color:#bfdbfe}
  .badge.moe{background:#f5f3ff;border-color:#ddd6fe}
  .badge.ln{background:#ecfdf5;border-color:#bbf7d0}
  .badge.cache{background:#fffbeb;border-color:#fde68a}
  .outpill{position:absolute;left:50%;transform:translateX(-50%);bottom:-20px;background:#ecfeff;border:1px solid #bae6fd;
    color:#0c4a6e;border-radius:999px;font-size:11px;padding:4px 10px;white-space:nowrap}
  /* Panels */
  .band, .panels{position:relative; z-index:1}
  .flow .panels{margin-top:24px}
  .panel img{width:100%; max-width:100%; height:auto; display:block; border:1px solid var(--line); border-radius:8px}
  .panel svg{width:100%; max-width:100%; height:auto; display:block; border:1px solid var(--line); border-radius:8px}
  .panels{display:grid;grid-template-columns:1fr 1fr;gap:0;border-top:1px solid var(--line);width:100%;max-width:1200px;margin:0 auto}
  .panel{background:#fff;border-right:1px solid var(--line)}
  .panel:last-child{border-right:0}
  .panel h2{margin:10px 16px 0;font-size:14px;color:#0369a1}
  .panel .hint{margin:4px 16px 8px;color:var(--muted);font-size:12px}
  .panel svg.diagram{width:100%;height:210px;display:block}
  /* SVG block hover effects */
  .attn-block, .moe-block{cursor:help;transition:opacity 0.2s}
  .attn-block:hover, .moe-block:hover{opacity:0.8}
  /* Pointer arrows */
  .ptr{position:absolute;left:0;top:0;transform:translate(-50%,-50%);z-index:2;filter:drop-shadow(0 2px 3px rgba(0,0,0,.1))}
  .ptr path{fill:var(--flow);stroke:var(--flow);stroke-width:1.5;stroke-linejoin:round;stroke-linecap:round}
  .ptr.cache path{fill:var(--cache);stroke:var(--cache)}
  /* Tooltips */
  .tip{position:fixed;pointer-events:none;z-index:10;background:#111827;color:#e5e7eb;padding:8px 10px;font-size:12px;border:1px solid #1f2937;border-radius:6px;
    box-shadow:0 10px 20px rgba(0,0,0,.25);opacity:0;transform:translate(-50%,-140%);transition:opacity .06s ease;white-space:nowrap}
  /* Controls */
  .controls{display:flex;align-items:center;gap:12px;padding:10px 24px;background:#f8fafc;border-top:1px solid var(--line)}
  .controls label{font-size:12px;color:var(--muted)}
  input[type="range"]{width:220px}
  @media (max-width:1100px){ .panels{grid-template-columns:1fr} }
</style>
</head>
<body>
<header>
  <h1>Mixture-of-Experts (MoE) Transformer — token → token</h1>
  <div class="sub">Compact pointer arrows between blocks. Bottom row begins under Attention and is offset one column to the right.</div>
</header>

<div class="legend">
  <span class="pillchip"><i class="sw" style="background:var(--flow)"></i>Pointer arrows</span>
  <span class="pillchip"><i class="sw" style="background:var(--attn)"></i>Attention</span>
  <span class="pillchip"><i class="sw" style="background:var(--moe)"></i>MoE</span>
  <span class="pillchip"><i class="sw" style="background:var(--ln)"></i>LayerNorm</span>
  <span class="pillchip"><i class="sw" style="background:var(--cache)"></i>KV Cache</span>
</div>

<div class="controls">
  <label for="zoom">Zoom</label>
  <input id="zoom" type="range" min="80" max="160" value="100">
  <span id="zv" style="font-size:12px;color:var(--muted)">100%</span>
</div>

<div class="wrap">
  <div class="flow" id="flow">
    <!-- Row 1: up to Attention + KV -->
    <div class="band" id="rowTop">
      <div class="node" id="n0" data-tip="Raw prompt or prior tokens.">
        <span class="badge">Input</span>
        <div class="title">Prompt (text)</div>
        <div class="meta">string</div>
        <div class="outpill">Output: text</div>
      </div>

      <div class="node" id="n1" data-tip="Subword segmentation to IDs (BPE/Unigram).">
        <span class="badge">Tokenizer</span>
        <div class="title">Tokenizer → IDs</div>
        <div class="meta">[id₁,…,id_T]</div>
        <div class="outpill">Output: list[int] (T)</div>
      </div>

      <div class="node" id="n2" data-tip="Look up dense vectors for token IDs; often tied with LM head.">
        <span class="badge">Embedding</span>
        <div class="title">Embedding Matrix</div>
        <div class="meta">E∈ℝ^{V×d}; X=E[ids]</div>
        <div class="outpill">Output: X ∈ ℝ^{T×d}</div>
      </div>

      <div class="node" id="n3" data-tip="Inject position info (RoPE/ALiBi).">
        <span class="badge">Positional</span>
        <div class="title">Positional Encoding</div>
        <div class="meta">RoPE / ALiBi</div>
        <div class="outpill">Output: Xᵖ ∈ ℝ^{T×d}</div>
      </div>

      <div class="node" id="n4" data-tip="Normalize per token; pre-LN architecture.">
        <span class="badge ln">LayerNorm</span>
        <div class="title">LayerNorm</div>
        <div class="meta">pre-attn</div>
        <div class="outpill">Output: ℝ^{T×d}</div>
      </div>

      <div class="node" id="n5" data-tip="Q,K,V projections → scaled dot-product → concat heads → linear.">
        <span class="badge attn">Attention</span>
        <div class="title">Multi-Head Self-Attention</div>
        <div class="meta">H heads, dₖ=d/H</div>
        <div class="outpill">Output: Attn(X) ∈ ℝ^{T×d}</div>
      </div>

      <div class="node small" id="n5a" data-tip="Reuse past K/V during decoding.">
        <span class="badge cache">KV Cache</span>
        <div class="title">KV Cache</div>
        <div class="meta">K,V ∈ ℝ^{T×H×dₖ}</div>
        <div class="outpill">I/O: append/read</div>
      </div>
    </div>

    <!-- Row 2: continue under Attention, visually right→left -->
    <div class="band bottom" id="rowBottom">
      <div class="node" id="n12" data-tip="Softmax to probabilities; sample next id (greedy/top-p).">
        <span class="badge">Decode</span>
        <div class="title">Softmax + Sampling</div>
        <div class="meta">p ∈ ℝ^{V} → id</div>
        <div class="outpill">Output: next id ∈ ℕ</div>
      </div>

      <div class="node" id="n11" data-tip="Linear projection to vocab; often weight-tied with embedding E.">
        <span class="badge">LM Head</span>
        <div class="title">LM Head</div>
        <div class="meta">xWᵀ, W∈ℝ^{V×d}</div>
        <div class="outpill">Output: logits ∈ ℝ^{V}</div>
      </div>

      <div class="node" id="n10" data-tip="Normalize before projecting to logits.">
        <span class="badge ln">LayerNorm</span>
        <div class="title">Final LayerNorm</div>
        <div class="meta">pre-LM head</div>
        <div class="outpill">Output: ℝ^{T×d}</div>
      </div>

      <div class="node" id="n9" data-tip="Add MoE result to residual stream.">
        <span class="badge">Residual</span>
        <div class="title">Residual Add</div>
        <div class="meta">… + MoE(x)</div>
        <div class="outpill">Output: ℝ^{T×d}</div>
      </div>

      <div class="node" id="n8" data-tip="Router picks Top-k experts per token; dispatch; experts run; combine.">
        <span class="badge moe">MoE</span>
        <div class="title">MoE Feed-Forward</div>
        <div class="meta">Top-k, capacity, combine</div>
        <div class="outpill">Output: MoE(X) ∈ ℝ^{T×d}; G ∈ ℝ^{T×E}</div>
      </div>

      <div class="node" id="n7" data-tip="Normalize before feed-forward / MoE.">
        <span class="badge ln">LayerNorm</span>
        <div class="title">LayerNorm</div>
        <div class="meta">pre-MoE</div>
        <div class="outpill">Output: ℝ^{T×d}</div>
      </div>

      <div class="node" id="n6" data-tip="Add attention result to residual stream.">
        <span class="badge">Residual</span>
        <div class="title">Residual Add</div>
        <div class="meta">x + Attn(x)</div>
        <div class="outpill">Output: ℝ^{T×d}</div>
      </div>
    </div>

    <div class="panels">
      <div class="panel">
        <h2>Multi-Head Self-Attention — expanded</h2>
        <div class="hint">Hover over blocks for explanations. Outputs under each block.</div>
        <svg viewBox="0 0 1500 210" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Attention internals">
          <defs>
            <marker id="arrowA" viewBox="0 0 12 12" refX="10" refY="6" markerWidth="10" markerHeight="10" orient="auto">
              <path d="M2,2 L10,6 L2,10 Z" fill="#0284c7"></path>
            </marker>
          </defs>
          <g transform="translate(20,48)">
            <rect x="0" y="0" width="210" height="110" rx="8" ry="8" fill="#eff6ff" stroke="#bfdbfe" class="attn-block" data-tip="Linear projections: Input X is projected into Query, Key, and Value matrices using learned weight matrices."></rect>
            <text x="105" y="30" text-anchor="middle" font-size="13">Linear: Q,K,V</text>
            <text x="105" y="54" text-anchor="middle" font-size="11" fill="#475569">Q,K,V ∈ ℝ^{T×H×dₖ}</text>
            <rect x="35" y="118" width="140" height="22" rx="10" ry="10" fill="#ecfeff" stroke="#bae6fd"></rect>
            <text x="105" y="133" text-anchor="middle" font-size="11" fill="#0c4a6e">Output: Q,K,V</text>

            <line x1="210" y1="55" x2="270" y2="55" stroke="#0284c7" stroke-width="2" marker-end="url(#arrowA)"></line>

            <rect x="270" y="0" width="170" height="110" rx="8" ry="8" fill="#eff6ff" stroke="#bfdbfe" class="attn-block" data-tip="Split heads: Q,K,V are reshaped to separate the H attention heads, each with dimension dₖ=d/H."></rect>
            <text x="355" y="62" text-anchor="middle" font-size="12">Split H heads</text>

            <line x1="440" y1="55" x2="520" y2="55" stroke="#0284c7" stroke-width="2" marker-end="url(#arrowA)"></line>

            <rect x="520" y="0" width="260" height="110" rx="8" ry="8" fill="#eff6ff" stroke="#bfdbfe" class="attn-block" data-tip="Scaled dot-product attention: Compute QK^T, scale by √dₖ, apply softmax to get attention weights."></rect>
            <text x="650" y="30" text-anchor="middle" font-size="12">QKᵀ/√dₖ → softmax</text>
            <text x="650" y="54" text-anchor="middle" font-size="11" fill="#475569">A ∈ ℝ^{T×T×H}</text>
            <rect x="585" y="118" width="130" height="22" rx="10" ry="10" fill="#ecfeff" stroke="#bae6fd"></rect>
            <text x="650" y="133" text-anchor="middle" font-size="11" fill="#0c4a6e">Output: A</text>

            <line x1="780" y1="55" x2="860" y2="55" stroke="#0284c7" stroke-width="2" marker-end="url(#arrowA)"></line>

            <rect x="860" y="0" width="220" height="110" rx="8" ry="8" fill="#eff6ff" stroke="#bfdbfe" class="attn-block" data-tip="Apply attention: Multiply attention weights A with Values V to get weighted representation."></rect>
            <text x="970" y="62" text-anchor="middle" font-size="12">A · V ∈ ℝ^{T×H×dₖ}</text>

            <line x1="1080" y1="55" x2="1160" y2="55" stroke="#0284c7" stroke-width="2" marker-end="url(#arrowA)"></line>

            <rect x="1160" y="0" width="240" height="110" rx="8" ry="8" fill="#eff6ff" stroke="#bfdbfe" class="attn-block" data-tip="Concatenate and project: Concatenate all heads and apply final linear projection Wᵒ."></rect>
            <text x="1280" y="30" text-anchor="middle" font-size="12">Concat heads → Wᵒ</text>
            <text x="1280" y="54" text-anchor="middle" font-size="11" fill="#475569">ℝ^{T×d}</text>
            <rect x="1200" y="118" width="160" height="22" rx="10" ry="10" fill="#ecfeff" stroke="#bae6fd"></rect>
            <text x="1280" y="133" text-anchor="middle" font-size="11" fill="#0c4a6e">Output: ℝ^{T×d}</text>

            <text x="1420" y="60" font-size="12" fill="#475569">→ Residual +</text>
          </g>
        </svg>
        <img src="Attention_diagram.png" alt="Self-attention diagram PNG" style="margin-top:16px">
      </div>
      <div class="panel">
        <h2>MoE Feed-Forward — vertical path</h2>
        <div class="hint">Hover over blocks for explanations. Router → Top-k → Capacity/Dispatch → Expert MLP → Combine.</div>
        <svg viewBox="0 0 1500 210" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="MoE internals">
          <defs>
            <marker id="arrowM" viewBox="0 0 12 12" refX="10" refY="6" markerWidth="10" markerHeight="10" orient="auto">
              <path d="M2,2 L10,6 L2,10 Z" fill="#0284c7"></path>
            </marker>
          </defs>

          <!-- Left column: router -->
          <g transform="translate(60,16)">
            <rect x="0" y="0" width="220" height="48" rx="8" ry="8" fill="#f5f3ff" stroke="#ddd6fe" class="moe-block" data-tip="Router network: Computes gating weights for each token to determine which experts to use."></rect>
            <text x="110" y="30" text-anchor="middle" font-size="13">Router: softmax(Wg·x)</text>
            <rect x="38" y="54" width="144" height="22" rx="10" ry="10" fill="#ecfeff" stroke="#bae6fd"></rect>
            <text x="110" y="69" text-anchor="middle" font-size="11" fill="#0c4a6e">Output: G ∈ ℝ^{T×E}</text>

            <line x1="110" y1="88" x2="110" y2="114" stroke="#0284c7" stroke-width="2" marker-end="url(#arrowM)"></line>

            <rect x="20" y="114" width="180" height="48" rx="8" ry="8" fill="#f5f3ff" stroke="#ddd6fe" class="moe-block" data-tip="Expert selection: Select top-k experts per token and apply capacity limits to balance load."></rect>
            <text x="110" y="142" text-anchor="middle" font-size="12">Top-k + Capacity</text>
            <rect x="48" y="164" width="124" height="22" rx="10" ry="10" fill="#ecfeff" stroke="#bae6fd"></rect>
            <text x="110" y="179" text-anchor="middle" font-size="11" fill="#0c4a6e">Output: indices/buckets</text>
          </g>

          <!-- Middle column: expert MLP vertical -->
          <g transform="translate(380,10)">
            <text x="110" y="16" text-anchor="middle" font-size="12" fill="#475569">Expert i — MLP</text>
            <!-- d -->
            <rect x="50" y="28" width="120" height="30" rx="6" ry="6" fill="#fff" stroke="#e5e7eb" class="moe-block" data-tip="Expert input: Each selected expert receives tokens assigned to it."></rect>
            <text x="110" y="48" text-anchor="middle" font-size="11">Input x ∈ ℝ^{d}</text>
            <line x1="110" y1="60" x2="110" y2="76" stroke="#0284c7" stroke-width="2" marker-end="url(#arrowM)"></line>
            <!-- expand -->
            <rect x="30" y="76" width="160" height="34" rx="6" ry="6" fill="#fff" stroke="#e5e7eb" class="moe-block" data-tip="First layer: Expand dimension from d to dff (typically 4×d) using weight matrix W₁."></rect>
            <text x="110" y="97" text-anchor="middle" font-size="11">W₁: d → d<tspan baseline-shift="sub">ff</tspan></text>
            <line x1="110" y1="110" x2="110" y2="126" stroke="#0284c7" stroke-width="2" marker-end="url(#arrowM)"></line>
            <!-- act -->
            <rect x="50" y="126" width="120" height="26" rx="6" ry="6" fill="#fff" stroke="#e5e7eb" class="moe-block" data-tip="Activation: Apply non-linear activation function (SwiGLU or GELU)."></rect>
            <text x="110" y="143" text-anchor="middle" font-size="11">SwiGLU / GELU</text>
            <line x1="110" y1="152" x2="110" y2="170" stroke="#0284c7" stroke-width="2" marker-end="url(#arrowM)"></line>
            <!-- project -->
            <rect x="30" y="170" width="160" height="34" rx="6" ry="6" fill="#fff" stroke="#e5e7eb" class="moe-block" data-tip="Second layer: Project back from dff to d using weight matrix W₂."></rect>
            <text x="110" y="191" text-anchor="middle" font-size="11">W₂: d<tspan baseline-shift="sub">ff</tspan> → d</text>
          </g>

          <!-- Right column: combine -->
          <g transform="translate(720,16)">
            <rect x="0" y="0" width="220" height="48" rx="8" ry="8" fill="#f5f3ff" stroke="#ddd6fe" class="moe-block" data-tip="Combine outputs: Aggregate expert outputs weighted by router gates, handling load balancing."></rect>
            <text x="110" y="30" text-anchor="middle" font-size="13">All-to-All + Combine</text>
            <rect x="38" y="54" width="144" height="22" rx="10" ry="10" fill="#ecfeff" stroke="#bae6fd"></rect>
            <text x="110" y="69" text-anchor="middle" font-size="11" fill="#0c4a6e">Output: ℝ^{T×d}</text>

            <text x="110" y="106" text-anchor="middle" font-size="11" fill="#475569">weighted by G</text>
            <!-- gating dots -->
            <g transform="translate(70,116)">
              <circle r="4" cx="-20" cy="0" fill="#7c3aed"></circle><circle r="4" cx="0" cy="0" fill="#7c3aed"></circle><circle r="4" cx="20" cy="0" fill="#7c3aed"></circle>
            </g>
          </g>

          <!-- horizontal arrows between columns -->
          <path d="M300 140 C 360 140, 340 60, 380 60" stroke="#0284c7" stroke-width="2" fill="none" marker-end="url(#arrowM)"></path>
          <path d="M540 190 C 620 190, 630 80, 720 80" stroke="#0284c7" stroke-width="2" fill="none" marker-end="url(#arrowM)"></path>
        </svg>
        <img src="MoE_FF.svg" alt="MoE feed-forward diagram SVG" style="margin-top:16px">
      </div>
    </div>
  </div>
</div>

<div class="controls" style="border-top:0"></div>

<div class="tip" id="tip">tip</div>

<script>
  const flow = document.getElementById('flow');
  const zoom = document.getElementById('zoom');
  const zv = document.getElementById('zv');
  const tip = document.getElementById('tip');

  // Tooltip for nodes and SVG blocks
  function setupTooltips(selector) {
    for (const elem of document.querySelectorAll(selector)){
      const t = elem.getAttribute('data-tip');
      if(!t) continue;
      elem.addEventListener('mousemove', e => { 
        tip.textContent = t; 
        tip.style.left = e.clientX+'px'; 
        tip.style.top = e.clientY+'px'; 
        tip.style.opacity = 1; 
      });
      elem.addEventListener('mouseleave', () => tip.style.opacity = 0);
    }
  }
  
  setupTooltips('.node');
  setupTooltips('.attn-block');
  setupTooltips('.moe-block');

  function clearPtrs(){ flow.querySelectorAll('.ptr').forEach(p=>p.remove()); }

  function centerOf(el){
    const r = el.getBoundingClientRect();
    const f = flow.getBoundingClientRect();
    return { x: r.left + r.width/2 - f.left, y: r.top + r.height/2 - f.top };
  }

  function addPtr(fromEl, toEl, cls=''){
    const a = centerOf(fromEl);
    const b = centerOf(toEl);
    
    // Calculate distance between elements
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const distance = Math.sqrt(dx*dx + dy*dy);

    const isCache = (cls && cls.indexOf('cache') !== -1);
    
    // Placement: cache arrows are centered; others are biased toward source
    const mid = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    const arrowPos = isCache ? mid : { x: a.x + dx * 0.4, y: a.y + dy * 0.4 };
    
    const angle = Math.atan2(dy, dx) * 180/Math.PI;

    // Size: cache arrows a bit shorter; others scale as before
    const arrowLength = isCache
      ? Math.min(Math.max(distance * 0.5, 60), 120)
      : Math.min(Math.max(distance * 0.6, 60), 120);
    const viewBoxWidth = arrowLength;

    const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svg.setAttribute('class', 'ptr' + (cls?(' '+cls):''));
    svg.setAttribute('viewBox',`0 0 ${viewBoxWidth} 20`);
    svg.style.width = arrowLength + 'px';
    svg.style.height = '20px';
    svg.style.left = arrowPos.x+'px';
    svg.style.top  = arrowPos.y+'px';
    svg.style.transform = `translate(-50%,-50%) rotate(${angle}deg)`;
    
    const path = document.createElementNS('http://www.w3.org/2000/svg','path');
    
    if (isCache) {
      // Double-headed arrow: <--->
      const leftHeadStart = 20;
      const leftHeadEnd = 5;
      const rightHeadStart = viewBoxWidth - 20;
      const rightHeadEnd = viewBoxWidth - 5;
      // Stem + right head + left head
      const d = [
        // stem
        `M ${leftHeadStart},10 L ${rightHeadStart},10`,
        // right head (points right)
        `M ${rightHeadStart},5 L ${rightHeadEnd},10 L ${rightHeadStart},15 Z`,
        // left head (points left)
        `M ${leftHeadStart},5 L ${leftHeadEnd},10 L ${leftHeadStart},15 Z`
      ].join(' ');
      path.setAttribute('d', d);
    } else {
      // Single-headed arrow with clear tail
      const tailStart = 5;
      const headStart = viewBoxWidth - 20;
      const headEnd = viewBoxWidth - 5;
      path.setAttribute('d',`M ${tailStart},10 L ${headStart},10 L ${headStart},5 L ${headEnd},10 L ${headStart},15 L ${headStart},10`);
    }
    
    svg.appendChild(path);
    flow.appendChild(svg);
  }

  function alignBottomRow(){
    // align n6 one full column + gap to the right of n5
    const bottom = document.getElementById('rowBottom');
    const attn = document.getElementById('n5');
    const n6 = document.getElementById('n6');

    if (!attn || !n6) return;

    const a = attn.getBoundingClientRect();
    const b6 = n6.getBoundingClientRect();
    const cs = getComputedStyle(bottom);
    const gap = parseFloat(cs.columnGap) || 0;
    const col = b6.width; // approximate grid-auto-columns width

    // No scale adjustment needed with CSS zoom
    const targetLeft = a.left + col + gap; // one step to the right of attention
    const delta = targetLeft - b6.left;
    bottom.style.marginLeft = delta + 'px';
  }

  function draw(){
    clearPtrs();
    alignBottomRow();

    const ids = ['n0','n1','n2','n3','n4','n5','n6','n7','n8','n9','n10','n11','n12'];
    for(let i=0;i<ids.length-1;i++){
      addPtr(document.getElementById(ids[i]), document.getElementById(ids[i+1]));
    }
    // KV cache pointer (double-headed)
    addPtr(document.getElementById('n5'), document.getElementById('n5a'), 'cache');

    // Decode loop pointers
    // addPtr(document.getElementById('n12'), document.getElementById('n1'));
    addPtr(document.getElementById('n12'), document.getElementById('n0'));
  }

  function setZoom(v){
	// make an allert of the page:
	  alert('imagine... you tought the zoom will work, zoom with keybinds');
    // // Use CSS zoom instead of transform to maintain proper positioning
    // flow.style.zoom = v / 100;
    // zv.textContent = v + '%';
    // // Small delay to let the browser apply zoom before recalculating
    // setTimeout(() => requestAnimationFrame(draw), 10);
  }
  
  zoom.addEventListener('input', e => {
    const value = parseInt(e.target.value, 10);
    setZoom(value);
  });

  // Initialize on load
  window.addEventListener('DOMContentLoaded', () => {
    setZoom(parseInt(zoom.value, 10));
  });
  
  // Redraw on window resize
  window.addEventListener('resize', () => {
    requestAnimationFrame(draw);
  });
</script>

</body>
</html>
